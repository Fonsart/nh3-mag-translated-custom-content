<?php
// phpcs:ignoreFile

namespace CliScripts;

use \Error;
use \stdClass;

require_once 'utils.php';

class PluginHeader {

	const DEFAULT_FILE      = 'plugin.json';
	const PACKAGE_JSON_FILE = 'package.json';

	/**
	 * Generates a plugin WordPress php file, using the content of the plugin.json file.
	 * The file will be saved in the root directory, using the lowercase `pluginName` value.
	 */
	public static function generate() {
		write();
		self::makeFile( self::loadHeaderConfig() );
	}

	/**
	 * Generates the plugin endpoint file based on the content of the `plugin.json` file.
	 * The resulting file will be stored at the root of your plugin folder,
	 * and be named with the lowercase value of the `pluginName` attribute.
	 */
	private static function makeFile( $config ) {
		$filename = normalizeName( $config->pluginName ) . '.php';
		$lines    = array(
			'<?php',
			'/**',
			" * Plugin Name: $config->pluginName",
			" * Description: $config->description",
			" * Version:     $config->version",
			" * Author:      $config->author",
			" * Author URI:  $config->authorUri",
			" * Text Domain: $config->textDomain",
			" * Domain Path: $config->domainPath",
			' */',
			'',
			'// THIS FILE IS AUTOMATICALLY GENERATED !',
			'// DO NOT ALTER ITS CONTENT',
		);

		if ( ! isset( $config->mainFileConstant ) || true === $config->mainFileConstant ) {
			$lines = array_merge(
				$lines, array(
					'',
					'// Main plugin file path',
					'define( \'' . (isset( $config->prefix) ? $config->prefix : normalizeName( $config->pluginName, '_', true )) . '_MAIN_FILE\', __FILE__ );',
				)
			);
		}

		if ( isset( $config->bootstrapFilePath ) ) {
			$lines = array_merge(
				$lines, array(
					'',
					'// Bootstrap the plugin.',
					"require_once '$config->bootstrapFilePath';",
				)
			);
		}

		if ( ! $handle = fopen( $filename, 'w' ) ) {
			write( "ERROR: Unable to open file \"$filename\"..." );
			exit;
		}

		foreach ( $lines as $line ) {
			$line .= PHP_EOL;
			if ( ! fwrite( $handle, $line ) ) {
				write( "ERROR: Unable to write to file \"$filename\"..." );
				exit;
			}
		}

		write( "SUCCESS: The plugin header file \"$filename\" has been generated." );

		fclose( $handle );
	}

	/**
	 * Load the header config file and returns it.
	 * The config can be defined two ways.
	 * 1. Using a plugin.json file that should have the following properties:
	 *   * `pluginName`
	 *   * `description`
	 *   * `version`
	 *   * `author`
	 *   * `authorUri`
	 *   * `textDomain`
	 *   * `domainPath`
	 *   * `bootstrapFilePath`
   *   " `prefix` (Optional)
   * 2. Using a package.json file that must have the following properties:
   *   * `description`
   *   * `version`
   *   * `author`
   *   It also must have a `wp` section which is an object with the following properties:
   *   * `pluginName`
   *   * `authorUri`
   *   * `textDomain`
   *   * `domainPath`
   *   * `bootstrapFilePath`
   *   " `prefix` (Optional)
	 * If none of those files are found in the project, the script will die after printing an error message.
	 * @return object The header config object with the same properties as the one expected on a plugin.json file (see above)
	 */
	private static function loadHeaderConfig() {
		if ( file_exists( self::DEFAULT_FILE ) ) {
			return loadConfigFrom( self::DEFAULT_FILE );
		} elseif ( file_exists( self::PACKAGE_JSON_FILE ) ) {

			define( 'REQ_PROPS', array( 'description', 'version', 'author', 'wp' ) );
			define( 'WP_REQ_PROPS', array( 'pluginName', 'authorUri', 'textDomain', 'domainPath', 'bootstrapFilePath' ) );

			$errors  = array();
			$package = loadConfigFrom( self::PACKAGE_JSON_FILE );

			foreach ( REQ_PROPS as $prop ) {
				if ( ! property_exists( $package, $prop ) ) {
					$errors[] = "Missing `$prop` property in your package.json file!";
				}
			}

			if ( property_exists( $package, 'wp' ) ) {
				foreach ( WP_REQ_PROPS as $prop ) {
					if ( ! property_exists( $package->wp, $prop ) ) {
						$errors[] = "Missing `$prop` property in the `wp` section of your package.json file!";
					}
				}
			}

			if ( ! empty( $errors ) ) {
				write( 'ERROR --- ' . count( $errors ) . ' error' . ( count( $errors ) > 1 ? 's' : '' ) . ' have beend detected while parsing the configuration file:' );
				foreach ( $errors as $key => $error ) {
					$key++;
					write( "  $key - $error" );
				}
				die();
			}

			$config                    = new stdClass();
			$config->description       = $package->description;
			$config->version           = $package->version;
			$config->author            = $package->author;
			$config->pluginName        = $package->wp->pluginName;
			$config->authorUri         = $package->wp->authorUri;
			$config->textDomain        = $package->wp->textDomain;
			$config->domainPath        = $package->wp->domainPath;
      $config->bootstrapFilePath = $package->wp->bootstrapFilePath;
      if ( isset( $package->wp->prefix ) ) {
        $config->prefix = $package->wp->prefix;
      }
			return $config;

		} else {
			write( 'ERROR --- No configuration file found in this project. Create a plugin.json or package.json file...' );
			die();
		}
	}

}
